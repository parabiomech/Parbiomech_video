<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parbiomech Video Analysis - ì‹œì  & êµ¬ê°„ & ìŠ¤í‚¤ ë¶„ì„</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 20px 20px 0 0;
        }

        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.95; }

        /* ì‚¬ìš© ê°€ì´ë“œ */
        .guide-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .guide-box h4 {
            color: #1976D2;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .guide-box ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .guide-box li {
            color: #555;
            margin-bottom: 5px;
        }

        .guide-box kbd {
            background: #f4f4f4;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .main-content { padding: 30px; }

        .upload-section {
            background: #f8f9fa;
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover { background: #e9ecef; border-color: #764ba2; }

        .video-container { display: none; margin-bottom: 30px; }
        .video-container.active { display: block; }

        video {
            width: 100%;
            max-height: 500px;
            border-radius: 10px;
            background: black;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success { background: #28a745; color: white; }
        .btn-success:hover { background: #218838; }
        
        .btn-warning { background: #ffc107; color: #000; }
        .btn-warning:hover { background: #e0a800; }
        
        .btn-danger { background: #dc3545; color: white; }
        .btn-danger:hover { background: #c82333; }
        
        .btn-info { background: #17a2b8; color: white; }
        .btn-info:hover { background: #138496; }

        .btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .mode-selector {
            background: linear-gradient(135deg, #e9ecef 0%, #f8f9fa 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            border: 2px solid #667eea;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .mode-selector h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .mode-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .mode-option {
            display: flex;
            align-items: center;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #dee2e6;
        }

        .mode-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.2);
        }

        .mode-option input[type="radio"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .mode-option label {
            font-weight: bold;
            cursor: pointer;
            margin: 0;
            font-size: 1.05em;
        }

        .mode-option input[type="radio"]:checked + label {
            color: #667eea;
        }

        .tags-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .tag-item {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            margin: 5px;
            font-size: 14px;
        }

        .tag-item.interval {
            background: #28a745;
        }

        .tag-item.interval-start {
            background: #ffc107;
            color: #000;
        }

        .tag-item.interval-end {
            background: #dc3545;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress-bar.active { display: block; }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .results-section {
            display: none;
            margin-top: 30px;
        }

        .results-section.active { display: block; }

        .result-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .image-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .image-box {
            text-align: center;
        }

        .image-box h5 {
            margin-bottom: 8px;
            color: #495057;
        }

        .result-image {
            width: 100%;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .result-image:hover { transform: scale(1.02); }

        .result-canvas {
            width: 100%;
            height: auto;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            display: block;
        }

        .angles-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .angles-table th,
        .angles-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .angles-table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .angles-table tr:hover { background: #f8f9fa; }

        .angles-table tbody tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        .angles-table tbody tr:hover {
            background: #e9ecef;
            transform: translateX(3px);
        }

        .angles-table tbody tr.highlighted {
            background: #fff3cd;
            font-weight: bold;
        }

        .graph-container {
            margin: 30px 0;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        canvas { max-height: 400px; }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner.active { display: block; }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            min-width: 300px;
            padding: 15px;
            border-radius: 8px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .alert { padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .alert-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .alert-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        .alert-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ Parbiomech Video Analysis</h1>
            <p>ì‹œì  ë¶„ì„ & êµ¬ê°„ ë¶„ì„ & ìŠ¤í‚¤ ë¶„ì„ ì‹œìŠ¤í…œ</p>
        </div>

        <div class="main-content">
            <!-- ì‚¬ìš© ê°€ì´ë“œ -->
            <div class="guide-box">
                <h4>ğŸ“– ì‚¬ìš© ë°©ë²•</h4>
                <ul>
                    <li><strong>1ë‹¨ê³„:</strong> ë¶„ì„í•  ì˜ìƒì„ ì—…ë¡œë“œí•˜ì„¸ìš”</li>
                    <li><strong>2ë‹¨ê³„:</strong> ë¶„ì„ ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš” (ì‹œì /êµ¬ê°„/ìŠ¤í‚¤)</li>
                    <li><strong>3ë‹¨ê³„:</strong> ì˜ìƒì„ ì¬ìƒí•˜ê³  <kbd>Space</kbd> í‚¤ë¥¼ ëˆŒëŸ¬ ë¶„ì„í•  ì‹œì ì„ ì„ íƒí•˜ì„¸ìš”</li>
                    <li><strong>ì‹œì  ë¶„ì„:</strong> ì„ íƒí•œ ì‹œì ì˜ ê´€ì ˆ ê°ë„ì™€ ìŠ¤ì¼ˆë ˆí†¤ì„ í™•ì¸í•©ë‹ˆë‹¤</li>
                    <li><strong>êµ¬ê°„ ë¶„ì„:</strong> ì‹œì‘~ë êµ¬ê°„ì˜ ê°ë„ ë³€í™”ì™€ ê¶¤ì ì„ ì‹œê³„ì—´ë¡œ ë¶„ì„í•©ë‹ˆë‹¤</li>
                    <li><strong>ìŠ¤í‚¤ ë¶„ì„:</strong> ì •ë©´ ì˜ìƒì—ì„œ 5ì„ (ë°œëª©/ê³¨ë°˜/ì–´ê¹¨/ìƒí•˜ì²´ ì¤‘ì‹¬ì„ )ê³¼ ê¸°ìš¸ê¸°ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤</li>
                    <li><strong>Tip:</strong> ê°ë„ í…Œì´ë¸”ì„ í´ë¦­í•˜ë©´ ìŠ¤ì¼ˆë ˆí†¤ì—ì„œ í•´ë‹¹ ê°ë„ê°€ ê°•ì¡°ë©ë‹ˆë‹¤ (Ctrl+í´ë¦­ìœ¼ë¡œ ì—¬ëŸ¬ ê°œ ì„ íƒ)</li>
                </ul>
            </div>

            <!-- ì—…ë¡œë“œ ì„¹ì…˜ -->
            <div class="upload-section" id="uploadSection">
                <h2>ğŸ“‚ ë¹„ë””ì˜¤ íŒŒì¼ ì„ íƒ</h2>
                <p style="margin: 15px 0;">MP4, AVI, MOV, WebM í˜•ì‹ ì§€ì›</p>
                <input type="file" id="videoInput" accept="video/*" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('videoInput').click()">
                    ğŸ“ íŒŒì¼ ì„ íƒ
                </button>
                <p style="margin-top: 15px; color: #6c757d; font-size: 14px;">
                    ë˜ëŠ” íŒŒì¼ì„ ì—¬ê¸°ë¡œ ë“œë˜ê·¸í•˜ì„¸ìš”
                </p>
            </div>

            <!-- ë¹„ë””ì˜¤ í”Œë ˆì´ì–´ -->
            <div class="video-container" id="videoContainer">
                <video id="videoPlayer" controls></video>

                <!-- ëª¨ë“œ ì„ íƒ -->
                <div class="mode-selector">
                    <h4>ğŸ¬ ë¶„ì„ ëª¨ë“œ ì„ íƒ</h4>
                    <div class="mode-options">
                        <div class="mode-option">
                            <input type="radio" name="analysisMode" value="timepoint" id="modeTimepoint" checked>
                            <label for="modeTimepoint">ğŸ“¸ ì‹œì  ë¶„ì„</label>
                        </div>
                        <div class="mode-option">
                            <input type="radio" name="analysisMode" value="interval" id="modeInterval">
                            <label for="modeInterval">ğŸ“Š êµ¬ê°„ ë¶„ì„</label>
                        </div>
                        <div class="mode-option">
                            <input type="radio" name="analysisMode" value="ski" id="modeSki">
                            <label for="modeSki">â›·ï¸ ìŠ¤í‚¤ ë¶„ì„ (ì •ë©´)</label>
                        </div>
                    </div>
                </div>

                <!-- ê´€ì ˆì  ì„ íƒ -->
                <div class="mode-selector">
                    <label><strong>ì¶”ì í•  ê´€ì ˆì :</strong></label>
                    <select id="keypointSelect" multiple size="6" style="width: 100%; padding: 8px; margin-top: 8px; border-radius: 8px;">
                        <option value="0" selected>ì½” (Nose)</option>
                        <option value="11" selected>ì™¼ìª½ ì–´ê¹¨ (Left Shoulder)</option>
                        <option value="12" selected>ì˜¤ë¥¸ìª½ ì–´ê¹¨ (Right Shoulder)</option>
                        <option value="13">ì™¼ìª½ íŒ”ê¿ˆì¹˜ (Left Elbow)</option>
                        <option value="14">ì˜¤ë¥¸ìª½ íŒ”ê¿ˆì¹˜ (Right Elbow)</option>
                        <option value="15" selected>ì™¼ìª½ ì†ëª© (Left Wrist)</option>
                        <option value="16" selected>ì˜¤ë¥¸ìª½ ì†ëª© (Right Wrist)</option>
                        <option value="23" selected>ì™¼ìª½ ì—‰ë©ì´ (Left Hip)</option>
                        <option value="24" selected>ì˜¤ë¥¸ìª½ ì—‰ë©ì´ (Right Hip)</option>
                        <option value="25" selected>ì™¼ìª½ ë¬´ë¦ (Left Knee)</option>
                        <option value="26" selected>ì˜¤ë¥¸ìª½ ë¬´ë¦ (Right Knee)</option>
                        <option value="27" selected>ì™¼ìª½ ë°œëª© (Left Ankle)</option>
                        <option value="28" selected>ì˜¤ë¥¸ìª½ ë°œëª© (Right Ankle)</option>
                    </select>
                    <p style="font-size: 12px; color: #6c757d; margin-top: 5px; text-align: center;">
                        Ctrl + í´ë¦­ìœ¼ë¡œ ì—¬ëŸ¬ ê°œ ì„ íƒ/í•´ì œ
                    </p>
                </div>

                <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
                <div class="controls">
                    <!-- ì‹œì  ë¶„ì„ ë²„íŠ¼ë“¤ -->
                    <div id="timepointControls">
                        <button class="btn btn-success" onclick="tagTimepoint()">
                            ğŸ·ï¸ ì‹œì  íƒœê·¸ (Space)
                        </button>
                        <button class="btn btn-primary" onclick="analyzeTimepoints()">
                            ğŸ” ì‹œì  ë¶„ì„ ì‹œì‘
                        </button>
                    </div>

                    <!-- êµ¬ê°„ ë¶„ì„ ë²„íŠ¼ë“¤ -->
                    <div id="intervalControls" style="display: none;">
                        <button class="btn btn-warning" onclick="tagIntervalStart()">
                            â–¶ï¸ êµ¬ê°„ ì‹œì‘ì 
                        </button>
                        <button class="btn btn-danger" onclick="tagIntervalEnd()">
                            â¹ï¸ êµ¬ê°„ ëì 
                        </button>
                        <button class="btn btn-info" onclick="analyzeInterval()">
                            ğŸ“Š êµ¬ê°„ ë¶„ì„ ì‹œì‘
                        </button>
                    </div>

                    <!-- ìŠ¤í‚¤ ë¶„ì„ ë²„íŠ¼ë“¤ -->
                    <div id="skiControls" style="display: none;">
                        <button class="btn btn-warning" onclick="tagIntervalStart()">
                            â–¶ï¸ êµ¬ê°„ ì‹œì‘ì 
                        </button>
                        <button class="btn btn-danger" onclick="tagIntervalEnd()">
                            â¹ï¸ êµ¬ê°„ ëì 
                        </button>
                        <button class="btn btn-info" onclick="analyzeSkiInterval()">
                            â›·ï¸ ìŠ¤í‚¤ ë¶„ì„ ì‹œì‘
                        </button>
                    </div>

                    <button class="btn btn-danger" onclick="clearAll()">
                        ğŸ—‘ï¸ ì „ì²´ ì‚­ì œ
                    </button>
                </div>

                <!-- íƒœê·¸ ëª©ë¡ -->
                <div class="tags-section">
                    <h3 id="tagsTitle">íƒœê·¸ ëª©ë¡</h3>
                    <div id="tagsContainer"></div>
                </div>
            </div>

            <!-- ì§„í–‰ë¥  -->
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>

            <div class="loading-spinner" id="loadingSpinner">
                <div class="spinner"></div>
                <p style="margin-top: 15px;">ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</p>
            </div>

            <!-- ê²°ê³¼ ì„¹ì…˜ -->
            <div class="results-section" id="resultsSection">
                <h2>ğŸ“Š ë¶„ì„ ê²°ê³¼</h2>
                <div id="resultsContainer"></div>
            </div>
        </div>
    </div>

    <!-- MediaPipe & Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        let videoElement = document.getElementById('videoPlayer');
        let pose = null;
        
        // ë°ì´í„° ì €ì¥
        let timepoints = []; // ì‹œì  ëª©ë¡
        let intervalStart = null; // êµ¬ê°„ ì‹œì‘
        let intervalEnd = null; // êµ¬ê°„ ë
        let currentMode = 'timepoint'; // í˜„ì¬ ëª¨ë“œ

        // MediaPipe ì´ˆê¸°í™”
        function initPose() {
            pose = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
        }

        // íŒŒì¼ ì—…ë¡œë“œ
        document.getElementById('videoInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        });

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­
        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.style.background = '#e9ecef';
        });
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.style.background = '#f8f9fa';
        });
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.style.background = '#f8f9fa';
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        });

        function loadVideo(file) {
            const url = URL.createObjectURL(file);
            videoElement.src = url;
            document.getElementById('videoContainer').classList.add('active');
            
            timepoints = [];
            intervalStart = null;
            intervalEnd = null;
            updateTagsDisplay();
            
            if (!pose) initPose();
        }

        // ëª¨ë“œ ì „í™˜
        document.querySelectorAll('input[name="analysisMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentMode = e.target.value;
                
                document.getElementById('timepointControls').style.display = 'none';
                document.getElementById('intervalControls').style.display = 'none';
                document.getElementById('skiControls').style.display = 'none';
                
                if (currentMode === 'timepoint') {
                    document.getElementById('timepointControls').style.display = 'block';
                } else if (currentMode === 'interval') {
                    document.getElementById('intervalControls').style.display = 'block';
                } else if (currentMode === 'ski') {
                    document.getElementById('skiControls').style.display = 'block';
                }
            });
        });

        // ì‹œì  íƒœê·¸
        function tagTimepoint() {
            const time = videoElement.currentTime;
            if (!timepoints.includes(time)) {
                timepoints.push(time);
                timepoints.sort((a, b) => a - b);
                updateTagsDisplay();
                showNotification('success', `âœ“ ì‹œì  ${time.toFixed(2)}ì´ˆ ì¶”ê°€`);
            }
        }

        // êµ¬ê°„ ì‹œì‘ì 
        function tagIntervalStart() {
            intervalStart = videoElement.currentTime;
            updateTagsDisplay();
            showNotification('warning', `â–¶ï¸ êµ¬ê°„ ì‹œì‘: ${intervalStart.toFixed(2)}ì´ˆ`);
        }

        // êµ¬ê°„ ëì 
        function tagIntervalEnd() {
            if (!intervalStart) {
                showNotification('warning', 'êµ¬ê°„ ì‹œì‘ì ì„ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”.');
                return;
            }
            
            intervalEnd = videoElement.currentTime;
            
            if (intervalEnd <= intervalStart) {
                showNotification('warning', 'ëì ì€ ì‹œì‘ì ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.');
                intervalEnd = null;
                return;
            }
            
            updateTagsDisplay();
            showNotification('info', `â¹ï¸ êµ¬ê°„ ë: ${intervalEnd.toFixed(2)}ì´ˆ`);
        }

        // ì „ì²´ ì‚­ì œ
        function clearAll() {
            if (confirm('ëª¨ë“  íƒœê·¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                timepoints = [];
                intervalStart = null;
                intervalEnd = null;
                updateTagsDisplay();
            }
        }

        // íƒœê·¸ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateTagsDisplay() {
            const container = document.getElementById('tagsContainer');
            const title = document.getElementById('tagsTitle');
            
            let html = '';
            
            if (currentMode === 'timepoint') {
                title.textContent = `ì‹œì  íƒœê·¸ (${timepoints.length}ê°œ)`;
                
                if (timepoints.length === 0) {
                    html = '<p style="color: #6c757d;">ì¶”ê°€ëœ ì‹œì ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                } else {
                    html = timepoints.map(t => 
                        `<span class="tag-item">${t.toFixed(2)}ì´ˆ</span>`
                    ).join('');
                }
            } else {
                title.textContent = 'êµ¬ê°„ ì„¤ì •';
                
                if (intervalStart !== null) {
                    html += `<span class="tag-item interval-start">ì‹œì‘: ${intervalStart.toFixed(2)}ì´ˆ</span>`;
                }
                if (intervalEnd !== null) {
                    html += `<span class="tag-item interval-end">ë: ${intervalEnd.toFixed(2)}ì´ˆ</span>`;
                }
                if (intervalStart !== null && intervalEnd !== null) {
                    const duration = intervalEnd - intervalStart;
                    html += `<span class="tag-item interval">êµ¬ê°„ ê¸¸ì´: ${duration.toFixed(2)}ì´ˆ</span>`;
                }
                
                if (intervalStart === null && intervalEnd === null) {
                    html = '<p style="color: #6c757d;">êµ¬ê°„ì„ ì„¤ì •í•˜ì„¸ìš”.</p>';
                }
            }
            
            container.innerHTML = html;
        }

        // ì‹œì  ë¶„ì„
        async function analyzeTimepoints() {
            if (timepoints.length === 0) {
                showNotification('warning', 'ë¶„ì„í•  ì‹œì ì„ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”.');
                return;
            }

            document.getElementById('progressBar').classList.add('active');
            document.getElementById('loadingSpinner').classList.add('active');

            frameAnalysisIndex = 0; // ì´ˆê¸°í™”
            const results = [];

            for (let i = 0; i < timepoints.length; i++) {
                const time = timepoints[i];
                updateProgress((i + 1) / timepoints.length * 100, `ì‹œì  ${i + 1}/${timepoints.length} ë¶„ì„ ì¤‘...`);
                
                const result = await analyzeFrame(time);
                result.displayIndex = i; // ê²°ê³¼ í‘œì‹œìš© ì¸ë±ìŠ¤
                results.push(result);
            }

            displayTimepointResults(results);

            // ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
            generateStroboscopeImages(results);

            document.getElementById('progressBar').classList.remove('active');
            document.getElementById('loadingSpinner').classList.remove('active');
            document.getElementById('resultsSection').classList.add('active');

            showNotification('success', 'âœ… ì‹œì  ë¶„ì„ ì™„ë£Œ!');
        }

        // ìŠ¤í‚¤ ë¶„ì„
        async function analyzeSkiInterval() {
            if (intervalStart === null || intervalEnd === null) {
                showNotification('warning', 'êµ¬ê°„ì˜ ì‹œì‘ì ê³¼ ëì ì„ ëª¨ë‘ ì„¤ì •í•˜ì„¸ìš”.');
                return;
            }

            document.getElementById('progressBar').classList.add('active');
            document.getElementById('loadingSpinner').classList.add('active');

            // êµ¬ê°„ ë‚´ í”„ë ˆì„ ìƒ˜í”Œë§ (0.1ì´ˆ ê°„ê²©)
            const frameInterval = 0.1;
            const frames = [];
            const frameData = [];

            let currentTime = intervalStart;
            let frameCount = 0;
            const totalFrames = Math.ceil((intervalEnd - intervalStart) / frameInterval);

            while (currentTime <= intervalEnd) {
                frameCount++;
                updateProgress((frameCount / totalFrames) * 100, `ìŠ¤í‚¤ ë¶„ì„ ì¤‘... ${frameCount}/${totalFrames} í”„ë ˆì„`);

                const result = await analyzeSkiFrame(currentTime);
                frames.push(result);
                
                // ê°ì§€ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ëª¨ë“  í”„ë ˆì„ ì €ì¥
                frameData.push({
                    time: currentTime,
                    landmarks: result.landmarks,
                    angles: result.angles
                });

                currentTime += frameInterval;
            }

            displaySkiIntervalResults(frameData);

            document.getElementById('progressBar').classList.remove('active');
            document.getElementById('loadingSpinner').classList.remove('active');
            document.getElementById('resultsSection').classList.add('active');

            showNotification('success', 'âœ… ìŠ¤í‚¤ ë¶„ì„ ì™„ë£Œ!');
        }

        // ìŠ¤í‚¤ ë¶„ì„ìš© í”„ë ˆì„ ë¶„ì„
        async function analyzeSkiFrame(time) {
            return new Promise((resolve) => {
                videoElement.currentTime = time;
                
                videoElement.onseeked = async () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                    
                    ctx.drawImage(videoElement, 0, 0);
                    const originalImage = canvas.toDataURL();
                    
                    pose.onResults((results) => {
                        if (results.poseLandmarks) {
                            const angles = calculateSkiAngles(results.poseLandmarks);
                            
                            resolve({
                                time,
                                originalImage,
                                landmarks: results.poseLandmarks,
                                angles,
                                detected: true
                            });
                        } else {
                            resolve({
                                time,
                                originalImage,
                                landmarks: null,
                                angles: null,
                                detected: false
                            });
                        }
                    });
                    
                    await pose.send({image: canvas});
                };
            });
        }

        // ìŠ¤í‚¤ ë¶„ì„ ê²°ê³¼ í‘œì‹œ
        function displaySkiIntervalResults(frameData) {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = `<h3>â›·ï¸ ìŠ¤í‚¤ ë¶„ì„ ê²°ê³¼ (ì •ë©´) - ${intervalStart.toFixed(2)}ì´ˆ ~ ${intervalEnd.toFixed(2)}ì´ˆ</h3>`;
            
            // ì•ˆë‚´ ë©”ì‹œì§€
            const infoDiv = document.createElement('div');
            infoDiv.className = 'alert alert-info';
            infoDiv.innerHTML = `
                <strong>ìŠ¤í‚¤ ë¶„ì„ ì •ë³´:</strong><br>
                â€¢ ë¶„ì„ êµ¬ê°„: ${intervalStart.toFixed(2)}ì´ˆ ~ ${intervalEnd.toFixed(2)}ì´ˆ (ì´ ${(intervalEnd - intervalStart).toFixed(2)}ì´ˆ)<br>
                â€¢ ìƒ˜í”Œë§: 0.1ì´ˆ ê°„ê²©<br>
                â€¢ ë¶„ì„ í”„ë ˆì„: ${frameData.length}ê°œ<br>
                â€¢ ë¶„ì„ í•­ëª©: ë°œëª©/ê³¨ë°˜/ì–´ê¹¨ ê¸°ìš¸ê¸°, ìƒí•˜ì²´ ìƒëŒ€ê°ë„
            `;
            container.appendChild(infoDiv);
            
            // êµ¬ê°„ ì˜ìƒ
            displaySkiIntervalVideos(frameData);
            
            // ê°ë„ ë³€í™” ê·¸ë˜í”„
            displaySkiAngleGraph(frameData);
            
            // ê´€ì ˆì  ê¶¤ì  ê·¸ë˜í”„
            displaySkiTrajectoryGraph(frameData);
            
            // ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
            generateSkiStroboscopeImages(frameData);
        }

        // ìŠ¤í‚¤ ë¶„ì„ ì˜ìƒ í‘œì‹œ
        function displaySkiIntervalVideos(frameData) {
            const videoDiv = document.createElement('div');
            videoDiv.className = 'result-card';
            videoDiv.innerHTML = `
                <h3>ğŸ¬ ìŠ¤í‚¤ ë¶„ì„ ì˜ìƒ</h3>
                <p class="info-text">ì•„ë˜ í‘œì—ì„œ í”„ë ˆì„ì„ í´ë¦­í•˜ë©´ í•´ë‹¹ ì‹œì ì˜ ì˜ìƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                <div class="image-comparison" style="margin-bottom: 20px;">
                    <div class="image-box">
                        <h5>ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤ + 5ì„ </h5>
                        <canvas id="skiOverlayCanvas" class="result-canvas"></canvas>
                        <p id="skiOverlayTime" style="margin-top: 8px; font-weight: bold; color: #667eea;"></p>
                    </div>
                    <div class="image-box">
                        <h5>ìŠ¤ì¼ˆë ˆí†¤ + 5ì„  + ê°ë„</h5>
                        <canvas id="skiSkeletonCanvas" class="result-canvas"></canvas>
                        <p id="skiSkeletonTime" style="margin-top: 8px; font-weight: bold; color: #667eea;"></p>
                    </div>
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="angles-table" id="skiFrameTable">
                        <thead>
                            <tr>
                                <th>í”„ë ˆì„</th>
                                <th>ì‹œê°„ (ì´ˆ)</th>
                                <th>ìƒíƒœ</th>
                            </tr>
                        </thead>
                        <tbody id="skiFrameTableBody"></tbody>
                    </table>
                </div>
            `;
            document.getElementById('resultsContainer').appendChild(videoDiv);
            
            // í”„ë ˆì„ í…Œì´ë¸” ì±„ìš°ê¸°
            const tbody = document.getElementById('skiFrameTableBody');
            frameData.forEach((frame, idx) => {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.innerHTML = `
                    <td>${idx + 1}</td>
                    <td>${frame.time.toFixed(2)}</td>
                    <td>${frame.landmarks ? 'âœ“ ê°ì§€ë¨' : 'âœ— ë¯¸ê°ì§€'}</td>
                `;
                row.onclick = () => showSkiFrame(frame, idx);
                tbody.appendChild(row);
            });
            
            // ì²« í”„ë ˆì„ ìë™ í‘œì‹œ
            if (frameData.length > 0) {
                showSkiFrame(frameData[0], 0);
            }
        }

        // ìŠ¤í‚¤ í”„ë ˆì„ í‘œì‹œ
        async function showSkiFrame(frame, frameIndex) {
            // í…Œì´ë¸” í•˜ì´ë¼ì´íŠ¸
            const rows = document.querySelectorAll('#skiFrameTableBody tr');
            rows.forEach(r => r.classList.remove('highlighted'));
            rows[frameIndex].classList.add('highlighted');
            
            // ì‹œê°„ í‘œì‹œ
            document.getElementById('skiOverlayTime').textContent = `ì‹œê°„: ${frame.time.toFixed(2)}ì´ˆ`;
            document.getElementById('skiSkeletonTime').textContent = `ì‹œê°„: ${frame.time.toFixed(2)}ì´ˆ`;
            
            if (!frame.landmarks) {
                // í¬ì¦ˆ ë¯¸ê°ì§€
                const overlayCanvas = document.getElementById('skiOverlayCanvas');
                const skeletonCanvas = document.getElementById('skiSkeletonCanvas');
                
                [overlayCanvas, skeletonCanvas].forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#F0F0F0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#999';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('í¬ì¦ˆ ë¯¸ê°ì§€', canvas.width / 2, canvas.height / 2);
                });
                return;
            }
            
            // ì›ë³¸ + 5ì„ 
            drawSkiOverlay(frame);
            
            // ìŠ¤ì¼ˆë ˆí†¤ + 5ì„  + ê°ë„
            drawSkiSkeleton(frame);
        }

        // ìŠ¤í‚¤ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawSkiOverlay(frame) {
            const canvas = document.getElementById('skiOverlayCanvas');
            const ctx = canvas.getContext('2d');
            
            videoElement.currentTime = frame.time;
            videoElement.onseeked = () => {
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                
                ctx.drawImage(videoElement, 0, 0);
                
                if (frame.landmarks) {
                    // ìŠ¤ì¼ˆë ˆí†¤
                    drawConnectors(ctx, frame.landmarks, POSE_CONNECTIONS, 
                        {color: '#00CED1', lineWidth: 4});
                    drawLandmarks(ctx, frame.landmarks, 
                        {color: '#FF1493', lineWidth: 2, radius: 6});
                    
                    // 5ì„  ê·¸ë¦¬ê¸°
                    drawSkiLines(ctx, frame.landmarks, canvas.width, canvas.height, false);
                }
            };
        }

        // ìŠ¤í‚¤ ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸°
        function drawSkiSkeleton(frame) {
            const canvas = document.getElementById('skiSkeletonCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            
            // í° ë°°ê²½
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (frame.landmarks) {
                // ìŠ¤ì¼ˆë ˆí†¤
                drawConnectors(ctx, frame.landmarks, POSE_CONNECTIONS, 
                    {color: '#00CED1', lineWidth: 5});
                drawLandmarks(ctx, frame.landmarks, 
                    {color: '#FF1493', lineWidth: 2, radius: 8});
                
                // 5ì„  + ê°ë„ í‘œì‹œ
                drawSkiLines(ctx, frame.landmarks, canvas.width, canvas.height, true);
                
                // ê°ë„ ìˆ˜ì¹˜ í‘œì‹œ
                if (frame.angles) {
                    displaySkiAnglesOnCanvas(ctx, frame.angles);
                }
            }
        }

        // ìŠ¤í‚¤ 5ì„  ê·¸ë¦¬ê¸°
        function drawSkiLines(ctx, landmarks, width, height, showAngles) {
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            
            if (!leftAnkle || !rightAnkle || !leftHip || !rightHip || !leftShoulder || !rightShoulder) return;
            
            // ì¤‘ì‹¬ì  ê³„ì‚°
            const ankleCenter = {
                x: (leftAnkle.x + rightAnkle.x) / 2 * width,
                y: (leftAnkle.y + rightAnkle.y) / 2 * height
            };
            const hipCenter = {
                x: (leftHip.x + rightHip.x) / 2 * width,
                y: (leftHip.y + rightHip.y) / 2 * height
            };
            const shoulderCenter = {
                x: (leftShoulder.x + rightShoulder.x) / 2 * width,
                y: (leftShoulder.y + rightShoulder.y) / 2 * height
            };
            
            ctx.lineWidth = 4;
            
            // 1. ë°œëª© ì—°ê²°ì„  (ë¹¨ê°•)
            ctx.strokeStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(leftAnkle.x * width, leftAnkle.y * height);
            ctx.lineTo(rightAnkle.x * width, rightAnkle.y * height);
            ctx.stroke();
            
            // 2. ê³¨ë°˜ ì—°ê²°ì„  (ì´ˆë¡)
            ctx.strokeStyle = '#00FF00';
            ctx.beginPath();
            ctx.moveTo(leftHip.x * width, leftHip.y * height);
            ctx.lineTo(rightHip.x * width, rightHip.y * height);
            ctx.stroke();
            
            // 3. ì–´ê¹¨ ì—°ê²°ì„  (íŒŒë‘)
            ctx.strokeStyle = '#0000FF';
            ctx.beginPath();
            ctx.moveTo(leftShoulder.x * width, leftShoulder.y * height);
            ctx.lineTo(rightShoulder.x * width, rightShoulder.y * height);
            ctx.stroke();
            
            // 4. í•˜ì²´ì„  (ë…¸ë‘)
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(ankleCenter.x, ankleCenter.y);
            ctx.lineTo(hipCenter.x, hipCenter.y);
            ctx.stroke();
            
            // 5. ìƒì²´ì„  (ìì£¼)
            ctx.strokeStyle = '#FF00FF';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(hipCenter.x, hipCenter.y);
            ctx.lineTo(shoulderCenter.x, shoulderCenter.y);
            ctx.stroke();
            
            // ì¤‘ì‹¬ì  í‘œì‹œ
            ctx.fillStyle = '#FFFFFF';
            [ankleCenter, hipCenter, shoulderCenter].forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // ìŠ¤í‚¤ ê°ë„ ìˆ˜ì¹˜ í‘œì‹œ
        function displaySkiAnglesOnCanvas(ctx, angles) {
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            
            let y = 40;
            const x = 25;
            
            ctx.fillText(`ë°œëª© ê¸°ìš¸ê¸°: ${angles['ë°œëª©_ê¸°ìš¸ê¸°']?.toFixed(1) || 'N/A'}Â°`, x, y);
            y += 35;
            ctx.fillText(`ê³¨ë°˜ ê¸°ìš¸ê¸°: ${angles['ê³¨ë°˜_ê¸°ìš¸ê¸°']?.toFixed(1) || 'N/A'}Â°`, x, y);
            y += 35;
            ctx.fillText(`ì–´ê¹¨ ê¸°ìš¸ê¸°: ${angles['ì–´ê¹¨_ê¸°ìš¸ê¸°']?.toFixed(1) || 'N/A'}Â°`, x, y);
            y += 35;
            ctx.fillText(`ìƒí•˜ì²´ ìƒëŒ€ê°ë„: ${angles['í•˜ì²´ìƒì²´_ìƒëŒ€ê°ë„']?.toFixed(1) || 'N/A'}Â°`, x, y);
        }

        // ìŠ¤í‚¤ ê°ë„ ê·¸ë˜í”„
        function displaySkiAngleGraph(frameData) {
            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph-container';
            graphDiv.innerHTML = '<h4>ğŸ“‰ ìŠ¤í‚¤ ê°ë„ ë³€í™”</h4><canvas id="skiAngleChart"></canvas>';
            document.getElementById('resultsContainer').appendChild(graphDiv);
            
            const canvas = document.getElementById('skiAngleChart');
            const ctx = canvas.getContext('2d');
            
            const times = frameData.map(f => f.time.toFixed(2));
            
            const datasets = [
                {
                    label: 'ë°œëª© ê¸°ìš¸ê¸°',
                    data: frameData.map(f => f.angles?.['ë°œëª©_ê¸°ìš¸ê¸°'] || null),
                    borderColor: '#FF0000',
                    backgroundColor: '#FF000033',
                    fill: false,
                    tension: 0.4
                },
                {
                    label: 'ê³¨ë°˜ ê¸°ìš¸ê¸°',
                    data: frameData.map(f => f.angles?.['ê³¨ë°˜_ê¸°ìš¸ê¸°'] || null),
                    borderColor: '#00FF00',
                    backgroundColor: '#00FF0033',
                    fill: false,
                    tension: 0.4
                },
                {
                    label: 'ì–´ê¹¨ ê¸°ìš¸ê¸°',
                    data: frameData.map(f => f.angles?.['ì–´ê¹¨_ê¸°ìš¸ê¸°'] || null),
                    borderColor: '#0000FF',
                    backgroundColor: '#0000FF33',
                    fill: false,
                    tension: 0.4
                },
                {
                    label: 'ìƒí•˜ì²´ ìƒëŒ€ê°ë„',
                    data: frameData.map(f => f.angles?.['í•˜ì²´ìƒì²´_ìƒëŒ€ê°ë„'] || null),
                    borderColor: '#FF00FF',
                    backgroundColor: '#FF00FF33',
                    fill: false,
                    tension: 0.4
                }
            ];
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: times,
                    datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'ì‹œê°„ (ì´ˆ)' } },
                        y: { title: { display: true, text: 'ê°ë„ (Â°)' } }
                    }
                }
            });
        }

        // ìŠ¤í‚¤ ê´€ì ˆì  ê¶¤ì  ê·¸ë˜í”„
        function displaySkiTrajectoryGraph(frameData) {
            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph-container';
            graphDiv.innerHTML = '<h4>ğŸ“ ìŠ¤í‚¤ ê´€ì ˆì  ê¶¤ì  (X-Y)</h4><canvas id="skiTrajectoryChart"></canvas>';
            document.getElementById('resultsContainer').appendChild(graphDiv);
            
            const canvas = document.getElementById('skiTrajectoryChart');
            const ctx = canvas.getContext('2d');
            
            // ì£¼ìš” ê´€ì ˆì  (ë°œëª©, ê³¨ë°˜, ì–´ê¹¨ ì¤‘ì‹¬)
            const datasets = [];
            const colors = {
                'ë°œëª©_ì¤‘ì‹¬': '#FF0000',
                'ê³¨ë°˜_ì¤‘ì‹¬': '#00FF00',
                'ì–´ê¹¨_ì¤‘ì‹¬': '#0000FF'
            };
            
            // ê° ì¤‘ì‹¬ì ì˜ ê¶¤ì  ê³„ì‚°
            Object.entries(colors).forEach(([name, color]) => {
                const trajectoryData = [];
                
                frameData.forEach(frame => {
                    if (!frame.landmarks) return;
                    
                    let centerX, centerY;
                    
                    if (name === 'ë°œëª©_ì¤‘ì‹¬') {
                        const left = frame.landmarks[27];
                        const right = frame.landmarks[28];
                        if (left && right) {
                            centerX = (left.x + right.x) / 2;
                            centerY = (left.y + right.y) / 2;
                        }
                    } else if (name === 'ê³¨ë°˜_ì¤‘ì‹¬') {
                        const left = frame.landmarks[23];
                        const right = frame.landmarks[24];
                        if (left && right) {
                            centerX = (left.x + right.x) / 2;
                            centerY = (left.y + right.y) / 2;
                        }
                    } else if (name === 'ì–´ê¹¨_ì¤‘ì‹¬') {
                        const left = frame.landmarks[11];
                        const right = frame.landmarks[12];
                        if (left && right) {
                            centerX = (left.x + right.x) / 2;
                            centerY = (left.y + right.y) / 2;
                        }
                    }
                    
                    if (centerX !== undefined && centerY !== undefined) {
                        trajectoryData.push({ x: centerX, y: 1 - centerY });
                    }
                });
                
                if (trajectoryData.length > 0) {
                    datasets.push({
                        label: name,
                        data: trajectoryData,
                        backgroundColor: color,
                        borderColor: color,
                        showLine: true,
                        tension: 0.4,
                        pointRadius: 4
                    });
                }
            });
            
            new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { 
                            title: { display: true, text: 'X ì¢Œí‘œ (ì¢Œìš°)' },
                            min: 0,
                            max: 1
                        },
                        y: { 
                            title: { display: true, text: 'Y ì¢Œí‘œ (ìƒí•˜)' },
                            min: 0,
                            max: 1
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // êµ¬ê°„ ë¶„ì„ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
        function generateIntervalStroboscopeImages(frameData) {
            const validFrames = frameData.filter(f => f.landmarks);
            
            if (validFrames.length === 0) return;
            
            const container = document.getElementById('resultsContainer');
            const stroboSection = document.createElement('div');
            stroboSection.className = 'result-card';
            stroboSection.innerHTML = `
                <h3>ğŸŒŸ êµ¬ê°„ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ (${validFrames.length}ê°œ í”„ë ˆì„)</h3>
                <p class="info-text">êµ¬ê°„ ë‚´ ëª¨ë“  í”„ë ˆì„ì˜ ìŠ¤ì¼ˆë ˆí†¤ì„ ì‹œê°„ ìˆœì„œëŒ€ë¡œ ìƒ‰ìƒ ë³€í™”ì™€ í•¨ê»˜ ê²¹ì³ì„œ ë™ì‘ íë¦„ì„ ì‹œê°í™”í•©ë‹ˆë‹¤</p>
                <div class="image-comparison">
                    <div class="image-box">
                        <h5>ì›ë³¸ ìŠ¤íŠ¸ë¡œëª¨ì…˜</h5>
                        <canvas id="intervalStroboOriginalCanvas" class="result-canvas"></canvas>
                    </div>
                    <div class="image-box">
                        <h5>ìŠ¤ì¼ˆë ˆí†¤ ìŠ¤íŠ¸ë¡œëª¨ì…˜ (ì‹œê°„ ìˆœì„œ ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜)</h5>
                        <canvas id="intervalStroboSkeletonCanvas" class="result-canvas"></canvas>
                    </div>
                </div>
            `;
            container.appendChild(stroboSection);
            
            setTimeout(() => {
                drawIntervalStroboscopeOriginal(validFrames);
                drawIntervalStroboscopeSkeleton(validFrames);
            }, 100);
        }

        async function drawIntervalStroboscopeOriginal(frames) {
            const canvas = document.getElementById('intervalStroboOriginalCanvas');
            if (!canvas) return;
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê° í”„ë ˆì„ì„ ìˆœì°¨ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
            const alpha = Math.min(0.2, 3.0 / frames.length);
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                await new Promise((resolve) => {
                    videoElement.currentTime = frame.time;
                    videoElement.onseeked = () => {
                        ctx.globalAlpha = alpha;
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        resolve();
                    };
                });
            }
            
            ctx.globalAlpha = 1.0;
        }

        function drawIntervalStroboscopeSkeleton(frames) {
            const canvas = document.getElementById('intervalStroboSkeletonCanvas');
            if (!canvas) return;
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì‹œê°„ ìˆœì„œ ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜ (ë…¸ë‘ -> íŒŒë‘ -> ì–´ë‘ìš´ íŒŒë‘)
            frames.forEach((frame, idx) => {
                if (!frame.landmarks) return;
                
                const progress = idx / (frames.length - 1);
                let color;
                
                if (progress < 0.5) {
                    // ë…¸ë‘ -> íŒŒë‘
                    const t = progress * 2;
                    const r = Math.floor(255 * (1 - t));
                    const g = Math.floor(255 * (1 - t));
                    const b = Math.floor(255 * t);
                    color = `rgb(${r}, ${g}, ${b})`;
                } else {
                    // íŒŒë‘ -> ì–´ë‘ìš´ íŒŒë‘
                    const t = (progress - 0.5) * 2;
                    const r = 0;
                    const g = 0;
                    const b = Math.floor(255 * (1 - t * 0.7));
                    color = `rgb(${r}, ${g}, ${b})`;
                }
                
                ctx.globalAlpha = 0.7;
                
                drawConnectors(ctx, frame.landmarks, POSE_CONNECTIONS, 
                    {color: color, lineWidth: 4});
                drawLandmarks(ctx, frame.landmarks, 
                    {color: color, lineWidth: 2, radius: 6});
            });
            
            ctx.globalAlpha = 1.0;
        }

        // ìŠ¤í‚¤ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
        function generateSkiStroboscopeImages(frameData) {
            const validFrames = frameData.filter(f => f.landmarks);
            
            if (validFrames.length === 0) return;
            
            const container = document.getElementById('resultsContainer');
            const stroboSection = document.createElement('div');
            stroboSection.className = 'result-card';
            stroboSection.innerHTML = `
                <h3>ğŸŒŸ ìŠ¤í‚¤ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ (${validFrames.length}ê°œ í”„ë ˆì„)</h3>
                <p class="info-text">ëª¨ë“  í”„ë ˆì„ì˜ ìŠ¤ì¼ˆë ˆí†¤ê³¼ 5ì„ ì„ ì‹œê°„ ìˆœì„œëŒ€ë¡œ ìƒ‰ìƒ ë³€í™”ì™€ í•¨ê»˜ ê²¹ì³ì„œ ë™ì‘ íë¦„ì„ ì‹œê°í™”í•©ë‹ˆë‹¤</p>
                <div class="image-comparison">
                    <div class="image-box">
                        <h5>ì›ë³¸ ìŠ¤íŠ¸ë¡œëª¨ì…˜</h5>
                        <canvas id="skiStroboOriginalCanvas" class="result-canvas"></canvas>
                    </div>
                    <div class="image-box">
                        <h5>ìŠ¤ì¼ˆë ˆí†¤ + 5ì„  ìŠ¤íŠ¸ë¡œëª¨ì…˜ (ì‹œê°„ ìˆœì„œ ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜)</h5>
                        <canvas id="skiStroboSkeletonCanvas" class="result-canvas"></canvas>
                    </div>
                </div>
            `;
            container.appendChild(stroboSection);
            
            setTimeout(() => {
                drawSkiStroboscopeOriginal(validFrames);
                drawSkiStroboscopeSkeleton(validFrames);
            }, 100);
        }

        async function drawSkiStroboscopeOriginal(frames) {
            const canvas = document.getElementById('skiStroboOriginalCanvas');
            if (!canvas) return;
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê° í”„ë ˆì„ì„ ìˆœì°¨ì ìœ¼ë¡œ ê·¸ë¦¬ê¸°
            const alpha = Math.min(0.2, 3.0 / frames.length);
            
            for (let i = 0; i < frames.length; i++) {
                const frame = frames[i];
                await new Promise((resolve) => {
                    videoElement.currentTime = frame.time;
                    videoElement.onseeked = () => {
                        ctx.globalAlpha = alpha;
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        resolve();
                    };
                });
            }
            
            ctx.globalAlpha = 1.0;
        }

        function drawSkiStroboscopeSkeleton(frames) {
            const canvas = document.getElementById('skiStroboSkeletonCanvas');
            if (!canvas) return;
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ì‹œê°„ ìˆœì„œ ìƒ‰ìƒ ê·¸ë¼ë°ì´ì…˜ (ë…¸ë‘ -> íŒŒë‘ -> ì–´ë‘ìš´ íŒŒë‘)
            frames.forEach((frame, idx) => {
                if (!frame.landmarks) return;
                
                const progress = idx / (frames.length - 1);
                let color;
                
                if (progress < 0.5) {
                    // ë…¸ë‘ -> íŒŒë‘
                    const t = progress * 2;
                    const r = Math.floor(255 * (1 - t));
                    const g = Math.floor(255 * (1 - t));
                    const b = Math.floor(255 * t);
                    color = `rgb(${r}, ${g}, ${b})`;
                } else {
                    // íŒŒë‘ -> ì–´ë‘ìš´ íŒŒë‘
                    const t = (progress - 0.5) * 2;
                    const r = 0;
                    const g = 0;
                    const b = Math.floor(255 * (1 - t * 0.7));
                    color = `rgb(${r}, ${g}, ${b})`;
                }
                
                ctx.globalAlpha = 0.7;
                
                drawConnectors(ctx, frame.landmarks, POSE_CONNECTIONS, 
                    {color: color, lineWidth: 4});
                drawLandmarks(ctx, frame.landmarks, 
                    {color: color, lineWidth: 2, radius: 6});
                
                // 5ì„ ë„ ê°™ì€ ìƒ‰ìƒìœ¼ë¡œ ê·¸ë¦¬ê¸° (ë” ë‘ê»ê²Œ)
                const originalStrokeStyle = ctx.strokeStyle;
                const originalLineWidth = ctx.lineWidth;
                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                
                const leftAnkle = frame.landmarks[27];
                const rightAnkle = frame.landmarks[28];
                const leftHip = frame.landmarks[23];
                const rightHip = frame.landmarks[24];
                const leftShoulder = frame.landmarks[11];
                const rightShoulder = frame.landmarks[12];
                
                if (leftAnkle && rightAnkle && leftHip && rightHip && leftShoulder && rightShoulder) {
                    const ankleCenter = {
                        x: (leftAnkle.x + rightAnkle.x) / 2 * canvas.width,
                        y: (leftAnkle.y + rightAnkle.y) / 2 * canvas.height
                    };
                    const hipCenter = {
                        x: (leftHip.x + rightHip.x) / 2 * canvas.width,
                        y: (leftHip.y + rightHip.y) / 2 * canvas.height
                    };
                    const shoulderCenter = {
                        x: (leftShoulder.x + rightShoulder.x) / 2 * canvas.width,
                        y: (leftShoulder.y + rightShoulder.y) / 2 * canvas.height
                    };
                    
                    // ë°œëª© ì—°ê²°ì„ 
                    ctx.beginPath();
                    ctx.moveTo(leftAnkle.x * canvas.width, leftAnkle.y * canvas.height);
                    ctx.lineTo(rightAnkle.x * canvas.width, rightAnkle.y * canvas.height);
                    ctx.stroke();
                    
                    // ê³¨ë°˜ ì—°ê²°ì„ 
                    ctx.beginPath();
                    ctx.moveTo(leftHip.x * canvas.width, leftHip.y * canvas.height);
                    ctx.lineTo(rightHip.x * canvas.width, rightHip.y * canvas.height);
                    ctx.stroke();
                    
                    // ì–´ê¹¨ ì—°ê²°ì„ 
                    ctx.beginPath();
                    ctx.moveTo(leftShoulder.x * canvas.width, leftShoulder.y * canvas.height);
                    ctx.lineTo(rightShoulder.x * canvas.width, rightShoulder.y * canvas.height);
                    ctx.stroke();
                    
                    // í•˜ì²´ì„ 
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(ankleCenter.x, ankleCenter.y);
                    ctx.lineTo(hipCenter.x, hipCenter.y);
                    ctx.stroke();
                    
                    // ìƒì²´ì„ 
                    ctx.beginPath();
                    ctx.moveTo(hipCenter.x, hipCenter.y);
                    ctx.lineTo(shoulderCenter.x, shoulderCenter.y);
                    ctx.stroke();
                }
                
                ctx.strokeStyle = originalStrokeStyle;
                ctx.lineWidth = originalLineWidth;
            });
            
            ctx.globalAlpha = 1.0;
        }

        // êµ¬ê°„ ë¶„ì„
        async function analyzeInterval() {
            if (intervalStart === null || intervalEnd === null) {
                showNotification('warning', 'êµ¬ê°„ì˜ ì‹œì‘ì ê³¼ ëì ì„ ëª¨ë‘ ì„¤ì •í•˜ì„¸ìš”.');
                return;
            }

            document.getElementById('progressBar').classList.add('active');
            document.getElementById('loadingSpinner').classList.add('active');

            // êµ¬ê°„ ë‚´ í”„ë ˆì„ ìƒ˜í”Œë§ (0.1ì´ˆ ê°„ê²©)
            const frameInterval = 0.1;
            const frames = [];
            const frameData = [];

            let currentTime = intervalStart;
            let frameCount = 0;
            const totalFrames = Math.ceil((intervalEnd - intervalStart) / frameInterval);

            while (currentTime <= intervalEnd) {
                frameCount++;
                updateProgress((frameCount / totalFrames) * 100, `êµ¬ê°„ ë¶„ì„ ì¤‘... ${frameCount}/${totalFrames} í”„ë ˆì„`);

                const result = await analyzeFrame(currentTime);
                frames.push(result);
                
                // ê°ì§€ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ëª¨ë“  í”„ë ˆì„ ì €ì¥
                frameData.push({
                    time: currentTime,
                    landmarks: result.landmarks,
                    angles: result.angles
                });

                currentTime += frameInterval;
            }

            displayIntervalResults(frameData);

            document.getElementById('progressBar').classList.remove('active');
            document.getElementById('loadingSpinner').classList.remove('active');
            document.getElementById('resultsSection').classList.add('active');

            showNotification('success', 'âœ… êµ¬ê°„ ë¶„ì„ ì™„ë£Œ!');
        }

        // í”„ë ˆì„ ë¶„ì„
        let frameAnalysisIndex = 0;
        
        async function analyzeFrame(time) {
            return new Promise((resolve) => {
                videoElement.currentTime = time;
                
                videoElement.onseeked = async () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                    
                    ctx.drawImage(videoElement, 0, 0);
                    const originalImage = canvas.toDataURL();
                    
                    pose.onResults((results) => {
                        if (results.poseLandmarks) {
                            // ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸°
                            drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, 
                                {color: '#00FF00', lineWidth: 4});
                            drawLandmarks(ctx, results.poseLandmarks, 
                                {color: '#FF0000', lineWidth: 2, radius: 6});
                            
                            const skeletonImage = canvas.toDataURL();
                            const angles = calculateAngles(results.poseLandmarks);
                            
                            // ì „ì—­ ë³€ìˆ˜ë¡œ ì €ì¥ (ë‚˜ì¤‘ì— ë‹¤ì‹œ ê·¸ë¦´ ë•Œ ì‚¬ìš©)
                            const idx = frameAnalysisIndex++;
                            window[`resultLandmarks_${idx}`] = results.poseLandmarks;
                            window[`resultAngles_${idx}`] = angles;
                            
                            resolve({
                                time,
                                originalImage,
                                skeletonImage,
                                landmarks: results.poseLandmarks,
                                angles,
                                detected: true,
                                analysisIndex: idx
                            });
                        } else {
                            const skeletonImage = canvas.toDataURL();
                            resolve({
                                time,
                                originalImage,
                                skeletonImage,
                                landmarks: null,
                                angles: null,
                                detected: false
                            });
                        }
                    });
                    
                    await pose.send({image: canvas});
                };
            });
        }

        // ìŠ¤í‚¤ ë¶„ì„ ê°ë„ ê³„ì‚° (ì •ë©´)
        function calculateSkiAngles(landmarks) {
            const angles = {};
            
            // ë°œëª©: 27(ì¢Œ), 28(ìš°)
            // ê³¨ë°˜: 23(ì¢Œ), 24(ìš°)
            // ì–´ê¹¨: 11(ì¢Œ), 12(ìš°)
            
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            
            if (leftAnkle && rightAnkle && leftHip && rightHip && leftShoulder && rightShoulder) {
                // ì¤‘ì‹¬ì  ê³„ì‚°
                const ankleCenter = {
                    x: (leftAnkle.x + rightAnkle.x) / 2,
                    y: (leftAnkle.y + rightAnkle.y) / 2
                };
                const hipCenter = {
                    x: (leftHip.x + rightHip.x) / 2,
                    y: (leftHip.y + rightHip.y) / 2
                };
                const shoulderCenter = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: (leftShoulder.y + rightShoulder.y) / 2
                };
                
                // ì—°ê²°ì„  ê¸°ìš¸ê¸° (ìˆ˜í‰ì„  ê¸°ì¤€)
                angles['ë°œëª©_ê¸°ìš¸ê¸°'] = calculateLineAngle(leftAnkle, rightAnkle);
                angles['ê³¨ë°˜_ê¸°ìš¸ê¸°'] = calculateLineAngle(leftHip, rightHip);
                angles['ì–´ê¹¨_ê¸°ìš¸ê¸°'] = calculateLineAngle(leftShoulder, rightShoulder);
                
                // í•˜ì²´ì„ /ìƒì²´ì„  ìƒëŒ€ê°ë„
                const lowerLineAngle = Math.atan2(hipCenter.y - ankleCenter.y, hipCenter.x - ankleCenter.x);
                const upperLineAngle = Math.atan2(shoulderCenter.y - hipCenter.y, shoulderCenter.x - hipCenter.x);
                
                let relativeAngle = Math.abs(upperLineAngle - lowerLineAngle) * (180 / Math.PI);
                if (relativeAngle > 180) relativeAngle = 360 - relativeAngle;
                
                angles['í•˜ì²´ìƒì²´_ìƒëŒ€ê°ë„'] = relativeAngle;
                
                // ì¤‘ì‹¬ì  ì €ì¥ (ê·¸ë¦¬ê¸°ìš©)
                angles['centers'] = { ankleCenter, hipCenter, shoulderCenter };
            }
            
            return angles;
        }

        // ë‘ ì ì„ ì‡ëŠ” ì„ ì˜ ìˆ˜í‰ì„  ê¸°ì¤€ ê¸°ìš¸ê¸° ê³„ì‚°
        function calculateLineAngle(p1, p2) {
            const rad = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            let angle = rad * (180 / Math.PI);
            // 0~180ë„ ë²”ìœ„ë¡œ ì •ê·œí™”
            if (angle < 0) angle += 180;
            return angle;
        }

        // ê°ë„ ê³„ì‚°
        function calculateAngles(landmarks) {
            const angles = { absolute: {}, relative: {} };
            
            // ì ˆëŒ€ê°ë„ - ë¶„ì ˆ ê¸°ìš¸ê¸°
            if (landmarks[11] && landmarks[13]) {
                angles.absolute['ì¢Œ_ìƒì™„'] = calculateSegmentAngle(landmarks[11], landmarks[13]);
            }
            if (landmarks[12] && landmarks[14]) {
                angles.absolute['ìš°_ìƒì™„'] = calculateSegmentAngle(landmarks[12], landmarks[14]);
            }
            if (landmarks[23] && landmarks[25]) {
                angles.absolute['ì¢Œ_ëŒ€í‡´'] = calculateSegmentAngle(landmarks[23], landmarks[25]);
            }
            if (landmarks[24] && landmarks[26]) {
                angles.absolute['ìš°_ëŒ€í‡´'] = calculateSegmentAngle(landmarks[24], landmarks[26]);
            }
            
            // ìƒëŒ€ê°ë„ - ê´€ì ˆê°ë„
            if (landmarks[11] && landmarks[13] && landmarks[15]) {
                angles.relative['ì¢Œ_íŒ”ê¿ˆì¹˜'] = calculateJointAngle(landmarks[11], landmarks[13], landmarks[15]);
            }
            if (landmarks[12] && landmarks[14] && landmarks[16]) {
                angles.relative['ìš°_íŒ”ê¿ˆì¹˜'] = calculateJointAngle(landmarks[12], landmarks[14], landmarks[16]);
            }
            if (landmarks[23] && landmarks[25] && landmarks[27]) {
                angles.relative['ì¢Œ_ë¬´ë¦'] = calculateJointAngle(landmarks[23], landmarks[25], landmarks[27]);
            }
            if (landmarks[24] && landmarks[26] && landmarks[28]) {
                angles.relative['ìš°_ë¬´ë¦'] = calculateJointAngle(landmarks[24], landmarks[26], landmarks[28]);
            }
            if (landmarks[11] && landmarks[23] && landmarks[25]) {
                angles.relative['ì¢Œ_ì—‰ë©ì´'] = calculateJointAngle(landmarks[11], landmarks[23], landmarks[25]);
            }
            if (landmarks[12] && landmarks[24] && landmarks[26]) {
                angles.relative['ìš°_ì—‰ë©ì´'] = calculateJointAngle(landmarks[12], landmarks[24], landmarks[26]);
            }
            
            return angles;
        }

        function calculateSegmentAngle(p1, p2) {
            const rad = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            let angle = rad * (180 / Math.PI);
            if (angle < 0) angle += 360;
            return angle;
        }

        function calculateJointAngle(a, b, c) {
            const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(rad * (180 / Math.PI));
            if (angle > 180) angle = 360 - angle;
            return angle;
        }

        // ì‹œì  ë¶„ì„ ê²°ê³¼ í‘œì‹œ
        function displayTimepointResults(results) {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = '<h3>ğŸ“¸ ì‹œì ë³„ ë¶„ì„ ê²°ê³¼</h3>';
            
            results.forEach((result, index) => {
                const card = document.createElement('div');
                card.className = 'result-card';
                card.id = `result-${index}`;
                
                let html = `<h3>ì‹œì  ${index + 1}: ${result.time.toFixed(2)}ì´ˆ</h3>`;
                
                html += `<div class="image-comparison">`;
                
                // ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤ ì˜¤ë²„ë ˆì´
                html += `<div class="image-box">`;
                html += `<h5>ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤ ì˜¤ë²„ë ˆì´</h5>`;
                html += `<canvas id="overlayCanvas-${index}" class="result-canvas"></canvas>`;
                html += `</div>`;
                
                // ìŠ¤ì¼ˆë ˆí†¤ë§Œ (ê°ë„ í‘œì‹œ) - í¬ë¡­ í™•ëŒ€
                html += `<div class="image-box">`;
                html += `<h5>ìŠ¤ì¼ˆë ˆí†¤ + ê°ë„ (í™•ëŒ€)</h5>`;
                html += `<canvas id="skeletonCanvas-${index}" class="result-canvas"></canvas>`;
                html += `</div>`;
                
                html += `</div>`;
                
                if (result.detected && result.angles) {
                    html += `<table class="angles-table" id="angleTable-${index}">`;
                    html += `<thead><tr><th>í•­ëª©</th><th>ê°ë„ (Â°)</th></tr></thead>`;
                    html += `<tbody>`;
                    
                    for (let [name, value] of Object.entries(result.angles.absolute)) {
                        html += `<tr data-angle-type="absolute" data-angle-name="${name}" onclick="highlightAngleOnSkeleton(${index}, 'absolute', '${name}')">`;
                        html += `<td>ì ˆëŒ€_${name}</td><td>${value.toFixed(2)}</td></tr>`;
                    }
                    for (let [name, value] of Object.entries(result.angles.relative)) {
                        html += `<tr data-angle-type="relative" data-angle-name="${name}" onclick="highlightAngleOnSkeleton(${index}, 'relative', '${name}')">`;
                        html += `<td>ê´€ì ˆ_${name}</td><td>${value.toFixed(2)}</td></tr>`;
                    }
                    
                    html += `</tbody></table>`;
                } else {
                    html += `<p style="color: #dc3545;">âš ï¸ í¬ì¦ˆë¥¼ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>`;
                }
                
                card.innerHTML = html;
                container.appendChild(card);
                
                // ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
                if (result.detected) {
                    setTimeout(() => {
                        drawOverlayCanvas(index, result);
                        drawSkeletonCanvas(index, result);
                    }, 100);
                }
            });
        }

        // ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawOverlayCanvas(index, result) {
            const canvas = document.getElementById(`overlayCanvas-${index}`);
            if (!canvas) return;
            
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                // ì›ë³¸ ì˜ìƒ
                ctx.drawImage(img, 0, 0);
                
                // ìŠ¤ì¼ˆë ˆí†¤ ì˜¤ë²„ë ˆì´ (ì„ ëª…í•œ ìƒ‰ìƒ)
                if (result.landmarks) {
                    drawConnectors(ctx, result.landmarks, POSE_CONNECTIONS, 
                        {color: '#00CED1', lineWidth: 5});
                    drawLandmarks(ctx, result.landmarks, 
                        {color: '#FF1493', lineWidth: 2, radius: 8});
                }
            };
            img.src = result.originalImage;
        }

        // ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
        function generateStroboscopeImages(results) {
            // í¬ì¦ˆê°€ ê°ì§€ëœ ê²°ê³¼ë§Œ í•„í„°ë§
            const validResults = results.filter(r => r.detected && r.landmarks);
            
            if (validResults.length === 0) {
                return;
            }
            
            const container = document.getElementById('resultsContainer');
            
            // ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì„¹ì…˜ ì¶”ê°€
            const stroboSection = document.createElement('div');
            stroboSection.className = 'result-card';
            stroboSection.innerHTML = `
                <h3>ğŸŒŸ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ (ëª¨ë“  ì‹œì  ì˜¤ë²„ë ˆì´)</h3>
                <p class="info-text">ëª¨ë“  ì‹œì ì˜ ì˜ìƒì„ í•œ ì¥ì˜ ì´ë¯¸ì§€ë¡œ í•©ì„±í•˜ì—¬ ë™ì‘ íë¦„ì„ ì‹œê°í™”í•©ë‹ˆë‹¤</p>
                <div class="image-comparison">
                    <div class="image-box">
                        <h5>ì›ë³¸ ìŠ¤íŠ¸ë¡œëª¨ì…˜ (${validResults.length}ê°œ ì‹œì )</h5>
                        <canvas id="stroboOriginalCanvas" class="result-canvas"></canvas>
                    </div>
                    <div class="image-box">
                        <h5>ìŠ¤ì¼ˆë ˆí†¤ ìŠ¤íŠ¸ë¡œëª¨ì…˜ (${validResults.length}ê°œ ì‹œì )</h5>
                        <canvas id="stroboSkeletonCanvas" class="result-canvas"></canvas>
                    </div>
                </div>
            `;
            container.appendChild(stroboSection);
            
            // ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
            setTimeout(() => {
                drawStroboscopeOriginal(validResults);
                drawStroboscopeSkeleton(validResults);
            }, 100);
        }

        // ì›ë³¸ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€
        function drawStroboscopeOriginal(results) {
            const canvas = document.getElementById('stroboOriginalCanvas');
            if (!canvas) return;
            
            // ì²« ë²ˆì§¸ ê²°ê³¼ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í¬ê¸° ì„¤ì •
            const firstImg = new Image();
            firstImg.onload = () => {
                canvas.width = firstImg.width;
                canvas.height = firstImg.height;
                const ctx = canvas.getContext('2d');
                
                // ê²€ì€ ë°°ê²½
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ê° ì‹œì ì˜ ì˜ìƒì„ ë°˜íˆ¬ëª…í•˜ê²Œ ê²¹ì³ ê·¸ë¦¬ê¸°
                const alpha = 1.0 / results.length; // íˆ¬ëª…ë„ ê³„ì‚°
                
                let loadedCount = 0;
                results.forEach((result, index) => {
                    const img = new Image();
                    img.onload = () => {
                        ctx.globalAlpha = alpha * 1.5; // ì¡°ê¸ˆ ë” ì§„í•˜ê²Œ
                        ctx.drawImage(img, 0, 0);
                        
                        loadedCount++;
                        if (loadedCount === results.length) {
                            // ëª¨ë“  ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
                            ctx.globalAlpha = 1.0;
                        }
                    };
                    img.src = result.originalImage;
                });
            };
            firstImg.src = results[0].originalImage;
        }

        // ìŠ¤ì¼ˆë ˆí†¤ ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€
        function drawStroboscopeSkeleton(results) {
            const canvas = document.getElementById('stroboSkeletonCanvas');
            if (!canvas) return;
            
            const firstImg = new Image();
            firstImg.onload = () => {
                canvas.width = firstImg.width;
                canvas.height = firstImg.height;
                const ctx = canvas.getContext('2d');
                
                // í° ë°°ê²½
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ê° ì‹œì ì˜ ìŠ¤ì¼ˆë ˆí†¤ì„ ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ ê²¹ì³ ê·¸ë¦¬ê¸°
                const colors = [
                    '#FF0000', '#00FF00', '#0000FF', '#FFA500', '#FF00FF',
                    '#00FFFF', '#FFD700', '#FF1493', '#00CED1', '#FF4500',
                    '#32CD32', '#8B4513', '#4B0082', '#DC143C', '#00FF7F'
                ];
                
                results.forEach((result, index) => {
                    if (!result.landmarks) return;
                    
                    const color = colors[index % colors.length];
                    const opacity = 0.6; // ë°˜íˆ¬ëª…
                    
                    // ì—°ê²°ì„ 
                    ctx.globalAlpha = opacity;
                    drawConnectors(ctx, result.landmarks, POSE_CONNECTIONS, 
                        {color: color, lineWidth: 4});
                    
                    // ê´€ì ˆì 
                    ctx.globalAlpha = opacity * 1.5;
                    drawLandmarks(ctx, result.landmarks, 
                        {color: color, lineWidth: 2, radius: 6});
                    
                    // ì‹œì  ë²ˆí˜¸ í‘œì‹œ (ì½” ìœ„ì¹˜ì—)
                    const nose = result.landmarks[0];
                    if (nose) {
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = color;
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${index + 1}`, 
                            nose.x * canvas.width, 
                            nose.y * canvas.height - 20);
                    }
                });
                
                ctx.globalAlpha = 1.0;
                
                // ë²”ë¡€ ì¶”ê°€
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                let legendY = 30;
                results.forEach((result, index) => {
                    const color = colors[index % colors.length];
                    ctx.fillStyle = color;
                    ctx.fillRect(20, legendY - 12, 15, 15);
                    ctx.fillStyle = '#000000';
                    ctx.fillText(`ì‹œì  ${index + 1}: ${result.time.toFixed(2)}ì´ˆ`, 45, legendY);
                    legendY += 25;
                    
                    // ë²”ë¡€ê°€ ë„ˆë¬´ ê¸¸ë©´ 2ì—´ë¡œ
                    if (legendY > canvas.height - 50 && index < results.length - 1) {
                        legendY = 30;
                        // ë‹¤ìŒ ì—´ë¡œ ì´ë™ (ê°„ë‹¨í•œ ë°©ë²•)
                    }
                });
            };
            firstImg.src = results[0].originalImage;
        }

        // ìŠ¤ì¼ˆë ˆí†¤ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
        function calculateBoundingBox(landmarks) {
            let minX = 1, minY = 1, maxX = 0, maxY = 0;
            
            landmarks.forEach(lm => {
                if (lm.x < minX) minX = lm.x;
                if (lm.x > maxX) maxX = lm.x;
                if (lm.y < minY) minY = lm.y;
                if (lm.y > maxY) maxY = lm.y;
            });
            
            // ì—¬ìœ  ê³µê°„ ì¶”ê°€ (20%)
            const width = maxX - minX;
            const height = maxY - minY;
            const padding = 0.2;
            
            minX = Math.max(0, minX - width * padding);
            minY = Math.max(0, minY - height * padding);
            maxX = Math.min(1, maxX + width * padding);
            maxY = Math.min(1, maxY + height * padding);
            
            return { minX, minY, maxX, maxY };
        }

        // ìŠ¤ì¼ˆë ˆí†¤ + ê°ë„ í‘œì‹œ ê·¸ë¦¬ê¸° (í¬ë¡­ í™•ëŒ€)
        let currentHighlightedAngle = null;

        function drawSkeletonCanvas(index, result, highlightAngle = null) {
            const canvas = document.getElementById(`skeletonCanvas-${index}`);
            if (!canvas) return;
            
            const img = new Image();
            img.onload = () => {
                const originalWidth = img.width;
                const originalHeight = img.height;
                
                // ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
                const bbox = calculateBoundingBox(result.landmarks);
                
                // í¬ë¡­ ì˜ì—­
                const cropX = bbox.minX * originalWidth;
                const cropY = bbox.minY * originalHeight;
                const cropWidth = (bbox.maxX - bbox.minX) * originalWidth;
                const cropHeight = (bbox.maxY - bbox.minY) * originalHeight;
                
                // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (ì›ë³¸ ë¹„ìœ¨ ìœ ì§€)
                canvas.width = originalWidth;
                canvas.height = originalHeight;
                const ctx = canvas.getContext('2d');
                
                // í° ë°°ê²½
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (result.landmarks) {
                    // ì¢Œí‘œ ë³€í™˜ (í¬ë¡­ ì˜ì—­ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°)
                    const transformedLandmarks = result.landmarks.map(lm => ({
                        x: (lm.x - bbox.minX) / (bbox.maxX - bbox.minX),
                        y: (lm.y - bbox.minY) / (bbox.maxY - bbox.minY),
                        z: lm.z,
                        visibility: lm.visibility
                    }));
                    
                    // ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸° (ë” êµµê³  ì„ ëª…í•˜ê²Œ)
                    drawConnectors(ctx, transformedLandmarks, POSE_CONNECTIONS, 
                        {color: '#00CED1', lineWidth: 6});
                    drawLandmarks(ctx, transformedLandmarks, 
                        {color: '#FF1493', lineWidth: 3, radius: 10});
                    
                    // ê°ë„ í˜¸ ê·¸ë¦¬ê¸°
                    if (result.angles) {
                        drawAngleArcs(ctx, transformedLandmarks, result.angles, canvas.width, canvas.height, highlightAngle);
                    }
                }
            };
            img.src = result.originalImage;
        }

        // ê°ë„ í˜¸ ê·¸ë¦¬ê¸°
        function drawAngleArcs(ctx, landmarks, angles, width, height, highlightAngle) {
            // ê´€ì ˆ ê°ë„ (3ì )
            const jointAngles = {
                'ì¢Œ_íŒ”ê¿ˆì¹˜': [11, 13, 15],
                'ìš°_íŒ”ê¿ˆì¹˜': [12, 14, 16],
                'ì¢Œ_ë¬´ë¦': [23, 25, 27],
                'ìš°_ë¬´ë¦': [24, 26, 28],
                'ì¢Œ_ì—‰ë©ì´': [11, 23, 25],
                'ìš°_ì—‰ë©ì´': [12, 24, 26]
            };
            
            for (let [name, indices] of Object.entries(jointAngles)) {
                if (!angles.relative[name]) continue;
                
                const [a, b, c] = indices.map(i => landmarks[i]);
                if (!a || !b || !c) continue;
                
                const isHighlighted = highlightAngle && 
                    highlightAngle.type === 'relative' && 
                    highlightAngle.name === name;
                
                const color = isHighlighted ? '#FF0000' : '#667eea';
                const lineWidth = isHighlighted ? 4 : 2;
                const radius = isHighlighted ? 40 : 25;
                
                drawArc(ctx, a, b, c, width, height, angles.relative[name], color, lineWidth, radius);
            }
            
            // ì ˆëŒ€ ê°ë„ (ë¶„ì ˆ ê¸°ìš¸ê¸°) - í™”ì‚´í‘œë¡œ í‘œì‹œ
            const segmentAngles = {
                'ì¢Œ_ìƒì™„': [11, 13],
                'ìš°_ìƒì™„': [12, 14],
                'ì¢Œ_ëŒ€í‡´': [23, 25],
                'ìš°_ëŒ€í‡´': [24, 26]
            };
            
            for (let [name, indices] of Object.entries(segmentAngles)) {
                if (!angles.absolute[name]) continue;
                
                const [p1, p2] = indices.map(i => landmarks[i]);
                if (!p1 || !p2) continue;
                
                const isHighlighted = highlightAngle && 
                    highlightAngle.type === 'absolute' && 
                    highlightAngle.name === name;
                
                const color = isHighlighted ? '#FF0000' : '#FFA500';
                const lineWidth = isHighlighted ? 5 : 3;
                
                drawSegmentAngle(ctx, p1, p2, width, height, angles.absolute[name], color, lineWidth);
            }
        }

        // í˜¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawArc(ctx, p1, center, p2, width, height, angleDegrees, color, lineWidth, radius) {
            const cx = center.x * width;
            const cy = center.y * height;
            
            const angle1 = Math.atan2((p1.y * height) - cy, (p1.x * width) - cx);
            const angle2 = Math.atan2((p2.y * height) - cy, (p2.x * width) - cx);
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            // ê°ë„ ì°¨ì´ ê³„ì‚°í•˜ì—¬ ì§§ì€ í˜¸ ê·¸ë¦¬ê¸°
            let diff = endAngle - startAngle;
            if (diff > Math.PI) {
                startAngle += 2 * Math.PI;
            } else if (diff < -Math.PI) {
                endAngle += 2 * Math.PI;
            }
            
            ctx.beginPath();
            ctx.arc(cx, cy, radius, startAngle, endAngle, false);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // ê°ë„ í…ìŠ¤íŠ¸
            const midAngle = (startAngle + endAngle) / 2;
            const textX = cx + Math.cos(midAngle) * (radius + 20);
            const textY = cy + Math.sin(midAngle) * (radius + 20);
            
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(angleDegrees.toFixed(1) + 'Â°', textX, textY);
        }

        // ë¶„ì ˆ ê°ë„ í™”ì‚´í‘œ ê·¸ë¦¬ê¸°
        function drawSegmentAngle(ctx, p1, p2, width, height, angleDegrees, color, lineWidth) {
            const x1 = p1.x * width;
            const y1 = p1.y * height;
            const x2 = p2.x * width;
            const y2 = p2.y * height;
            
            // ì¤‘ì 
            const mx = (x1 + x2) / 2;
            const my = (y1 + y2) / 2;
            
            // ë¶„ì ˆ ë°©í–¥
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            // ìˆ˜í‰ì„  (ê¸°ì¤€ì„ )
            const refLen = len * 0.4;
            ctx.beginPath();
            ctx.moveTo(mx - refLen, my);
            ctx.lineTo(mx + refLen, my);
            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ë¶„ì ˆ ê°•ì¡°
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            
            // ê°ë„ í…ìŠ¤íŠ¸
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(angleDegrees.toFixed(1) + 'Â°', mx + 40, my - 10);
        }

        // í…Œì´ë¸” í´ë¦­ ì‹œ ê°ë„ í•˜ì´ë¼ì´íŠ¸
        function highlightAngleOnSkeleton(index, angleType, angleName) {
            // í…Œì´ë¸” í•˜ì´ë¼ì´íŠ¸
            const table = document.getElementById(`angleTable-${index}`);
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => row.classList.remove('highlighted'));
            
            const clickedRow = table.querySelector(`tr[data-angle-type="${angleType}"][data-angle-name="${angleName}"]`);
            if (clickedRow) {
                clickedRow.classList.add('highlighted');
            }
            
            // ìŠ¤ì¼ˆë ˆí†¤ ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (í•´ë‹¹ ê°ë„ ê°•ì¡°)
            const result = {
                originalImage: document.querySelector(`#result-${index} .result-image`).src,
                landmarks: window[`resultLandmarks_${index}`],
                angles: window[`resultAngles_${index}`]
            };
            
            drawSkeletonCanvas(index, result, { type: angleType, name: angleName });
        }

        // êµ¬ê°„ ë¶„ì„ ê²°ê³¼ í‘œì‹œ
        function displayIntervalResults(frameData) {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = `<h3>ğŸ“Š êµ¬ê°„ ë¶„ì„ ê²°ê³¼ (${intervalStart.toFixed(2)}ì´ˆ ~ ${intervalEnd.toFixed(2)}ì´ˆ)</h3>`;
            
            // ì•ˆë‚´ ë©”ì‹œì§€
            const infoDiv = document.createElement('div');
            infoDiv.className = 'alert alert-info';
            infoDiv.innerHTML = `
                <strong>êµ¬ê°„ ë¶„ì„ ì •ë³´:</strong><br>
                â€¢ ë¶„ì„ êµ¬ê°„: ${intervalStart.toFixed(2)}ì´ˆ ~ ${intervalEnd.toFixed(2)}ì´ˆ (ì´ ${(intervalEnd - intervalStart).toFixed(2)}ì´ˆ)<br>
                â€¢ ìƒ˜í”Œë§: 0.1ì´ˆ ê°„ê²©<br>
                â€¢ ë¶„ì„ í”„ë ˆì„: ${frameData.length}ê°œ
            `;
            container.appendChild(infoDiv);
            
            // êµ¬ê°„ ì˜ìƒ ìƒì„±
            displayIntervalVideos(frameData);
            
            // ê¶¤ì  ê·¸ë˜í”„
            displayTrajectoryGraph(frameData);
            
            // ê°ë„ ë³€í™” ê·¸ë˜í”„
            displayAngleGraph(frameData);
            
            // ìŠ¤íŠ¸ë¡œëª¨ì…˜ ì´ë¯¸ì§€ ìƒì„±
            generateIntervalStroboscopeImages(frameData);
        }

        // êµ¬ê°„ ì˜ìƒ í‘œì‹œ
        function displayIntervalVideos(frameData) {
            const videoDiv = document.createElement('div');
            videoDiv.className = 'result-card';
            videoDiv.innerHTML = `
                <h3>ğŸ¬ êµ¬ê°„ ì˜ìƒ</h3>
                <p class="info-text">ì•„ë˜ í‘œì—ì„œ í”„ë ˆì„ì„ í´ë¦­í•˜ë©´ í•´ë‹¹ ì‹œì ì˜ ì˜ìƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>
                <div class="image-comparison" style="margin-bottom: 20px;">
                    <div class="image-box">
                        <h5>ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤</h5>
                        <canvas id="intervalOverlayCanvas" class="result-canvas"></canvas>
                        <p id="intervalOverlayTime" style="margin-top: 8px; font-weight: bold; color: #667eea;"></p>
                    </div>
                    <div class="image-box">
                        <h5>ìŠ¤ì¼ˆë ˆí†¤ + ê°ë„ + ê¶¤ì </h5>
                        <canvas id="intervalSkeletonCanvas" class="result-canvas"></canvas>
                        <p id="intervalSkeletonTime" style="margin-top: 8px; font-weight: bold; color: #667eea;"></p>
                    </div>
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="angles-table" id="intervalFrameTable">
                        <thead>
                            <tr>
                                <th>í”„ë ˆì„</th>
                                <th>ì‹œê°„ (ì´ˆ)</th>
                                <th>ìƒíƒœ</th>
                            </tr>
                        </thead>
                        <tbody id="intervalFrameTableBody"></tbody>
                    </table>
                </div>
            `;
            document.getElementById('resultsContainer').appendChild(videoDiv);
            
            // í”„ë ˆì„ í…Œì´ë¸” ì±„ìš°ê¸°
            const tbody = document.getElementById('intervalFrameTableBody');
            frameData.forEach((frame, idx) => {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.innerHTML = `
                    <td>${idx + 1}</td>
                    <td>${frame.time.toFixed(2)}</td>
                    <td>${frame.landmarks ? 'âœ“ ê°ì§€ë¨' : 'âœ— ë¯¸ê°ì§€'}</td>
                `;
                row.onclick = () => showIntervalFrame(frame, frameData, idx);
                tbody.appendChild(row);
            });
            
            // ì²« í”„ë ˆì„ ìë™ í‘œì‹œ
            if (frameData.length > 0) {
                showIntervalFrame(frameData[0], frameData, 0);
            }
        }

        // êµ¬ê°„ íŠ¹ì • í”„ë ˆì„ í‘œì‹œ
        async function showIntervalFrame(frame, allFrames, frameIndex) {
            // í…Œì´ë¸” í•˜ì´ë¼ì´íŠ¸
            const rows = document.querySelectorAll('#intervalFrameTableBody tr');
            rows.forEach(r => r.classList.remove('highlighted'));
            rows[frameIndex].classList.add('highlighted');
            
            // ì‹œê°„ í‘œì‹œ
            document.getElementById('intervalOverlayTime').textContent = `ì‹œê°„: ${frame.time.toFixed(2)}ì´ˆ`;
            document.getElementById('intervalSkeletonTime').textContent = `ì‹œê°„: ${frame.time.toFixed(2)}ì´ˆ`;
            
            if (!frame.landmarks) {
                // í¬ì¦ˆ ë¯¸ê°ì§€
                const overlayCanvas = document.getElementById('intervalOverlayCanvas');
                const skeletonCanvas = document.getElementById('intervalSkeletonCanvas');
                
                [overlayCanvas, skeletonCanvas].forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#F0F0F0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#999';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('í¬ì¦ˆ ë¯¸ê°ì§€', canvas.width / 2, canvas.height / 2);
                });
                return;
            }
            
            // ì›ë³¸ + ìŠ¤ì¼ˆë ˆí†¤
            drawIntervalOverlay(frame);
            
            // ìŠ¤ì¼ˆë ˆí†¤ + ê°ë„ + ê¶¤ì 
            drawIntervalSkeleton(frame, allFrames, frameIndex);
        }

        // êµ¬ê°„ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        function drawIntervalOverlay(frame) {
            const canvas = document.getElementById('intervalOverlayCanvas');
            const ctx = canvas.getContext('2d');
            
            // ë¹„ë””ì˜¤ì—ì„œ í”„ë ˆì„ ì¶”ì¶œ
            videoElement.currentTime = frame.time;
            videoElement.onseeked = () => {
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                
                ctx.drawImage(videoElement, 0, 0);
                
                if (frame.landmarks) {
                    drawConnectors(ctx, frame.landmarks, POSE_CONNECTIONS, 
                        {color: '#00CED1', lineWidth: 5});
                    drawLandmarks(ctx, frame.landmarks, 
                        {color: '#FF1493', lineWidth: 2, radius: 8});
                }
            };
        }

        // êµ¬ê°„ ìŠ¤ì¼ˆë ˆí†¤ + ê°ë„ + ê¶¤ì  ê·¸ë¦¬ê¸°
        function drawIntervalSkeleton(currentFrame, allFrames, currentIndex) {
            const canvas = document.getElementById('intervalSkeletonCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            
            // í° ë°°ê²½
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!currentFrame.landmarks) return;
            
            // 1. ê³¼ê±° ê¶¤ì  ê·¸ë¦¬ê¸° (íë¦¿í•˜ê²Œ)
            const select = document.getElementById('keypointSelect');
            const selectedIndices = Array.from(select.selectedOptions).map(opt => parseInt(opt.value));
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFA500', '#800080', 
                           '#FF1493', '#00CED1', '#FFD700', '#8B4513', '#4B0082'];
            
            selectedIndices.forEach((kpIndex, colorIdx) => {
                ctx.strokeStyle = colors[colorIdx % colors.length] + '66'; // 40% íˆ¬ëª…ë„
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let firstPoint = true;
                allFrames.slice(0, currentIndex + 1).forEach(frame => {
                    if (frame.landmarks && frame.landmarks[kpIndex]) {
                        const x = frame.landmarks[kpIndex].x * canvas.width;
                        const y = frame.landmarks[kpIndex].y * canvas.height;
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                ctx.stroke();
                
                // í˜„ì¬ ìœ„ì¹˜ ì  ê°•ì¡°
                if (currentFrame.landmarks[kpIndex]) {
                    ctx.fillStyle = colors[colorIdx % colors.length];
                    ctx.beginPath();
                    ctx.arc(
                        currentFrame.landmarks[kpIndex].x * canvas.width,
                        currentFrame.landmarks[kpIndex].y * canvas.height,
                        8, 0, 2 * Math.PI
                    );
                    ctx.fill();
                }
            });
            
            // 2. í˜„ì¬ ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸° (ì„ ëª…í•œ ìƒ‰ìƒ)
            drawConnectors(ctx, currentFrame.landmarks, POSE_CONNECTIONS, 
                {color: '#00CED1', lineWidth: 5});
            drawLandmarks(ctx, currentFrame.landmarks, 
                {color: '#FF1493', lineWidth: 2, radius: 8});
            
            // 3. ê°ë„ í˜¸ ê·¸ë¦¬ê¸°
            if (currentFrame.angles) {
                drawAngleArcs(ctx, currentFrame.landmarks, currentFrame.angles, 
                    canvas.width, canvas.height, null);
            }
        }

        // ê¶¤ì  ê·¸ë˜í”„
        function displayTrajectoryGraph(frameData) {
            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph-container';
            graphDiv.innerHTML = '<h4>ğŸ“ˆ ê´€ì ˆì  ê¶¤ì  (ì„ íƒëœ ê´€ì ˆì )</h4><canvas id="trajectoryChart"></canvas>';
            document.getElementById('resultsContainer').appendChild(graphDiv);
            
            const canvas = document.getElementById('trajectoryChart');
            const ctx = canvas.getContext('2d');
            
            // ì„ íƒëœ ê´€ì ˆì  ê°€ì ¸ì˜¤ê¸°
            const select = document.getElementById('keypointSelect');
            const selectedOptions = Array.from(select.selectedOptions);
            
            if (selectedOptions.length === 0) {
                ctx.font = '16px Arial';
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';
                ctx.fillText('ê´€ì ˆì ì„ ì„ íƒí•´ì£¼ì„¸ìš”', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const keypointNames = {
                '0': 'ì½”',
                '11': 'ì¢Œ_ì–´ê¹¨',
                '12': 'ìš°_ì–´ê¹¨',
                '13': 'ì¢Œ_íŒ”ê¿ˆì¹˜',
                '14': 'ìš°_íŒ”ê¿ˆì¹˜',
                '15': 'ì¢Œ_ì†ëª©',
                '16': 'ìš°_ì†ëª©',
                '23': 'ì¢Œ_ì—‰ë©ì´',
                '24': 'ìš°_ì—‰ë©ì´',
                '25': 'ì¢Œ_ë¬´ë¦',
                '26': 'ìš°_ë¬´ë¦',
                '27': 'ì¢Œ_ë°œëª©',
                '28': 'ìš°_ë°œëª©'
            };
            
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFA500', '#800080', 
                           '#FF1493', '#00CED1', '#FFD700', '#8B4513', '#4B0082',
                           '#DC143C', '#00FF7F', '#FF4500'];
            
            const datasets = [];
            
            selectedOptions.forEach((option, idx) => {
                const index = parseInt(option.value);
                const name = keypointNames[option.value] || `Point ${index}`;
                
                const xData = [];
                const yData = [];
                
                frameData.forEach(frame => {
                    if (frame.landmarks && frame.landmarks[index]) {
                        xData.push(frame.landmarks[index].x);
                        yData.push(1 - frame.landmarks[index].y); // Yì¶• ë’¤ì§‘ê¸°
                    }
                });
                
                if (xData.length > 0) {
                    datasets.push({
                        label: name,
                        data: xData.map((x, i) => ({x, y: yData[i]})),
                        backgroundColor: colors[idx % colors.length],
                        borderColor: colors[idx % colors.length],
                        showLine: true,
                        tension: 0.3
                    });
                }
            });
            
            new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { 
                            title: { display: true, text: 'X ì¢Œí‘œ (ì¢Œìš°)' },
                            min: 0,
                            max: 1
                        },
                        y: { 
                            title: { display: true, text: 'Y ì¢Œí‘œ (ìƒí•˜)' },
                            min: 0,
                            max: 1
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // ê°ë„ ë³€í™” ê·¸ë˜í”„
        function displayAngleGraph(frameData) {
            const graphDiv = document.createElement('div');
            graphDiv.className = 'graph-container';
            graphDiv.innerHTML = '<h4>ğŸ“‰ ê°ë„ ë³€í™”</h4><canvas id="angleChart"></canvas>';
            document.getElementById('resultsContainer').appendChild(graphDiv);
            
            const canvas = document.getElementById('angleChart');
            const ctx = canvas.getContext('2d');
            
            const times = frameData.map(f => f.time.toFixed(2));
            
            const datasets = [];
            const angleNames = ['ì¢Œ_íŒ”ê¿ˆì¹˜', 'ìš°_íŒ”ê¿ˆì¹˜', 'ì¢Œ_ë¬´ë¦', 'ìš°_ë¬´ë¦'];
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFA500'];
            
            angleNames.forEach((name, index) => {
                const angleData = frameData.map(f => 
                    f.angles?.relative?.[name] || null
                );
                
                datasets.push({
                    label: name,
                    data: angleData,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '33',
                    fill: false,
                    tension: 0.4
                });
            });
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: times,
                    datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'ì‹œê°„ (ì´ˆ)' } },
                        y: { title: { display: true, text: 'ê°ë„ (Â°)' } }
                    }
                }
            });
        }

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        function updateProgress(percent, message) {
            const fill = document.getElementById('progressFill');
            fill.style.width = percent + '%';
            fill.textContent = Math.round(percent) + '% - ' + message;
        }

        // ì•Œë¦¼ í‘œì‹œ
        function showNotification(type, message) {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} notification`;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && videoElement.src && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                if (currentMode === 'timepoint') {
                    tagTimepoint();
                }
            }
        });
    </script>
</body>
</html>